# Евгений Борисов — Spring-потрошитель, часть 1

Ребята, всем добрый день! Я очень рад, что вас так много собралось, практически как на JPoint.

Давайте немножко скажем два слова о себе. Я занимаюсь Java с 2001 года. Последние пару лет я ушёл в свободные художники, потому что надоело работать с разными начальниками. Опыт показывает, что либо проект большой и стабильный, но там очень медленно двигаются технологии и там можно надолго застрять на чём-то, либо всё очень нестабильно и приходится работать по ночам.

Поэтому сейчас я пишу курсы, страдаю от аллергии на весну, но при этом люблю Spring. Вот такой вот парадокс.

## Терминология

Очень важно мне немножко объяснить про терминологию, потому что я живу в Израиле, и у нас некоторые вещи называются не так, как называются здесь. Часто проводят тренинги люди, которые сначала стесняются говорить, что "А, так это ты говорил Ethernet, а мы думали EtherNet", и вот это всё накапливается.

Поэтому давайте я сразу внесу ясность в вопрос:
- Если я говорю "аппликация", я подразумеваю приложение
- Если я говорю Ethernet, я имею в виду Ethernet
- Если я говорю "штрудель", я имею в виду собаку (@)
- Компонент я могу использовать с любым ударением: могу сказать "компонЕнт", могу сказать "кОмпонент"
- Параметр - это тоже свободно

## План лекции

Сегодня мы с вами поговорим про составляющие Spring Application Context'а, которые существуют, и попытаемся написать пятый. Мы поговорим про то, как сделать всякие разные нестандартные сложные вещи, и в конце мы поговорим о том, как Spring бьёт по нашей производительности.

Можно было бы этот доклад озаглавить как "Spring в картинках". Здесь можно в принципе изучить всё что существует. То есть я выворачиваю кишки Spring'а. Вот это в принципе то, что мы с вами будем обсуждать. Некоторые вещи мы напишем по ходу дела.

## История Spring

Давайте разбираться. Кто знает, что произошло 26 ноября 2003 года?

Нет, первая версия Spring вышла ещё в 2002 году. Мне, кстати, на самом деле интересно, что там собственно вышло, потому что в 2003 году...

При Spring мы прописываем XML и из этого поднимаем контекст, и соответственно против этого работаем. Для того чтобы всё это заработало, нам нужен XML, который является внутренним компонентом Spring, который сканирует XML и всё что там мы пишем, переводит в bean definition - такие объекты, которые хранят в себе информацию про beans.

## Практический пример

Давайте посмотрим, как изначально декларировались beans в Spring.

Мы быстренько сделаем код. Кстати, я извиняюсь перед Вовой, что он это видит третий раз за последние 3 дня.

У нас будет интерфейс Quoter - это цитатник. У нашего цитатника будет метод, который будет называться `sayQuote()`, и напишем имплементацию, которая будет называться TerminatorQuoter.

Сделаем сеттеры, потому что для того чтобы настраивать всё через XML, обязательно нужно делать сеттеры. Потому что если вы сделали просто поле и не поставили сеттер, с точки зрения Spring это просто не bean. Он попытается всё равно через сеттер вызвать его, но его нет, и всё упадёт.

Теперь мы внесём это всё в наш XML файл. Как вы видите, этот XML файл выглядит так: у меня открывается тег `<beans>`, закрывается тег `</beans>`, и внутри я прописываю beans.

```xml
<bean id="terminatorQuoter" class="TerminatorQuoter">
    <property name="message" value="I'll be back"/>
</bean>
```

Мы прописываем bean, который будет называться terminatorQuoter из класса TerminatorQuoter. Дадим ему какой-то ID на всякий пожарный, и пропишем property. Поскольку у нас сеттер есть, то IntelliJ предвидит, что можно через указание property message дать какое-то значение.

## Загрузка контекста

Теперь мы напишем какой-нибудь main или тест. Я не уверен, что у меня подключён JUnit, поэтому будет просто main.

Кстати, был как-то в одной компании на консультации, спросил: "Вы используете тесты?" Они говорят: "Да, да, мы пишем тесты." Я говорю: "А как вы пишете тесты?" Он говорит: "Ну как - создаём прямо в том же классе, который надо протестировать, очень удобно прямо там." Создаём объект из этого класса, запускаем, смотрим - если 17, то нормально. Вот это не называется тестированием! Нужен JUnit, нужно всё, нужно... но мы сейчас просто так для нас.

Теперь мы в нашем main создаём XMLApplicationContext. Имплементация вот этого контекста как раз сканирует вот этим XML, про который мы поговорили. Я сюда должен передать название файла config.xml. XML у меня назывался config.xml.

Дальше можно будет вытащить из этого контекста bean. По интерфейсу можно вытаскивать, по классу можно вытаскивать. Знаете что, давайте я специально сейчас по классу вытащу, чтобы потом объяснить вам, что это неправильно.

```java
TerminatorQuoter quoter = context.getBean(TerminatorQuoter.class);
quoter.sayQuote();
```

Запустим этот main, проверим, что всё работает, пойдём дальше. "I'll be back" у нас напечатал - всё замечательно.

## Как это работает внутри

Как это в принципе всё работало в 2003 году? Потом просто очень много вещей накрутилось, и у нас тоже по презентации потом очень много чего добавится.

Мы пишем наши классы вот так. Я представляю: центральный игрок Spring - это BeanFactory, который отвечает за создание и хранение всех объектов, которые у него настроены.

Вот так выглядит наш древний старый XML. Мы там прописываем какой-то bean из какого-то класса. После этого, когда мы поднимаем контекст, первое что происходит - приходит вот этот BeanDefinitionReader, считывает с этого XML все декларации beans и кладёт их вот в такую map - то есть такую map "имя бина против его декларации".

Что входит в декларацию? Это:
- Из какого класса его надо создавать
- Если у него есть init-method, то как он называется
- Какие у него properties
- Все другие подробности бина, которые мы прописали в XML

После того как эти BeanDefinition созданы, BeanFactory начинает по ним работать - создаёт из наших классов объекты и все beans складывает в контейнер.

Тут важно знать, что если bean является singleton, то по умолчанию он создаётся изначально. То есть как только поднимается контекст, по умолчанию все singleton сразу создаются и складываются в контейнер. А все prototype создаются в тот момент, когда они нужны. То есть кто-то запросил prototype - в этот момент Spring создал, настроил, отдал и забыл про него.

Это важно знать, потому что, например, если вы прописываете destroy-method для бина, то для singleton destroy-method работать будет, потому что в тот момент когда контекст закрывается, Spring проходит по всем beans (которые здесь хранятся - это только singletons), находит их destroy-methods, если они прописаны, и запускает. А prototype он просто нигде не хранит, и соответственно для prototype destroy-method никогда не работает.

## BeanPostProcessor

Следующая вещь в кишках Spring - это BeanPostProcessor. Зачем нужен BeanPostProcessor и что он делает? Он позволяет настраивать наши beans до того, как они ещё попали в контейнер. То есть мы чуть позже увидим картинку, как все beans проходят через BeanPostProcessor в момент создания.

Если знаете, есть такой design pattern, называется Chain of Responsibility. Он в принципе здесь как раз задействован.

Давайте посмотрим, что такое BeanPostProcessor и что я вообще могу хотеть сделать. Я сейчас хочу кастомизировать Spring. Я хочу его обучить каким-то своим собственным аннотациям и хочу написать какой-нибудь BeanPostProcessor, который к ним будет относиться и что-то подкручивать в bean в тот момент, когда bean будет создаваться.

### Пример: InjectRandomInt

Давайте придумаем такую вещь. Представьте себе, что я пишу приложение, в котором есть очень много генерации случайных чисел, и вот эти случайные значения чисел я хочу чтобы они заходили в поля. И я смотрю, как работают все люди, которые со мной в команде, и каждый это делает по-своему: кто-то использует Math.random(), кто-то использует Random класс и метод nextInt(), кто-то какую-то библиотеку скачал. Каждый делает это по-своему, тратит на это время, силы.

Я говорю: "Стоп, ребята, это никуда не годится! Давайте мы это будем делать декларативно." Аннотацию, которая будет называться @InjectRandomInt, мы её будем ставить на тех полях, в которые мы хотим чтобы инжектилось случайное число, а потом мы обучим Spring к этой аннотации относиться и в момент создания bean'а настраивать его относительно этой аннотации.

Смотрите, как мы это реализуем:

```java
@Retention(RetentionPolicy.RUNTIME)
public @interface InjectRandomInt {
    int min();
    int max();
}
```

Создаём аннотацию. Очень важно, когда вы пишете свои аннотации, не забудьте поменять retention policy. По умолчанию кто знает, какой retention policy?

SOURCE говорит о том, что данная аннотация видна исключительно в source коде. Когда вы компилируете в byte-code, уже ничего не будет. Например, @Override - аннотация такого плана. Она нужна только в процессе разработки кода.

CLASS - это retention policy, которая говорит, что аннотация в byte-code попасть должна, но при этом всё равно через reflection в runtime вы считать её не сможете. Это нужно для всяких ASM трансформаций, для byte-code instrumentation.

RUNTIME - это тот policy, который у большинства аннотаций, которые видны в runtime, которые через reflection можно считать.

У данной аннотации мы сказали, что есть два параметра, оба int: min и max.

Теперь в Terminator добавим поле:

```java
@InjectRandomInt(min = 2, max = 7)
private int repeat;
```

И будем использовать это поле в sayQuote():

```java
public void sayQuote() {
    for (int i = 0; i < repeat; i++) {
        System.out.println(message);
    }
}
```

Что произойдёт, когда я запущу всё это дело? Почему не запускается? Потому что у меня никто не знает про аннотацию @InjectRandomInt. Соответственно у меня параметр repeat является 0, и 0 раз напечатается цитата Терминатора.

### Создание BeanPostProcessor

Теперь мы будем обучать Spring. Мы сейчас создадим класс, который имплементирует интерфейс BeanPostProcessor, который будет отвечать за обработку всех beans классы которых имеют эту аннотацию хотя бы в каком-то поле.

```java
public class InjectRandomIntAnnotationBeanPostProcessor implements BeanPostProcessor {

    @Override
    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
        Class<?> beanClass = bean.getClass();
        Field[] fields = beanClass.getDeclaredFields();

        for (Field field : fields) {
            InjectRandomInt annotation = field.getAnnotation(InjectRandomInt.class);
            if (annotation != null) {
                int min = annotation.min();
                int max = annotation.max();
                Random random = new Random();
                int randomValue = min + random.nextInt(max - min);

                field.setAccessible(true);
                ReflectionUtils.setField(field, bean, randomValue);
            }
        }
        return bean;
    }

    @Override
    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
        return bean;
    }
}
```

Кстати, знаете, аннотацию @Autowired - кто за неё отвечает, за её обработку? Вы уже можете догадаться, потому что я использую те же конвенции: AutowiredAnnotationBeanPostProcessor. Поэтому если вы придумаете свои процессоры, которые обрабатывают ваши кастомные аннотации, то старайтесь соблюдать их конвенции - так просто будет удобнее читать код.

Чтобы расширять Spring, нужно имплементировать два метода:
- `postProcessBeforeInitialization` - вызывается до init-method
- `postProcessAfterInitialization` - вызывается после init-method

Каждый метод имеет одинаковую сигнатуру: в метод придёт bean, соответственно для каждого bean'а этот метод дёргается, приходит bean, его имя, и я в этом методе могу вернуть какой-то объект. Теоретически я могу вернуть вообще не тот объект, который мне пришёл, но пока мы не будем извращаться.

Следующий вопрос: написал я этот замечательный класс, что мне нужно сделать для того, чтобы Spring про этот класс узнал? Для того чтобы этот BeanPostProcessor являлся частью системы, которая создаёт и настраивает мои beans?

Просто прописать его в контекст! Совершенно верно. У Spring'а вы прописываете bean в контекст. Причём прописать в контекст - опять у нас есть разные варианты: можно в XML (если мы работаем с XML), можно в Java config, можно там через аннотации. Пока мы с XML.

```xml
<bean class="InjectRandomIntAnnotationBeanPostProcessor"/>
```

ID ему давать абсолютно не нужно. ID дают для чего? Потому что мы хотим куда-то инжектить, и соответственно мы через ID указываем его. Но поскольку это инфраструктурный bean, то зачем ему ID? Spring конечно ему какой-то ID придумает дурацкий, но мне это не интересно.

Теперь мы запускаем то же самое приложение, и по идее... сколько я там сказал, от 2 до 7? Ну вот 5 раз получилось. Ещё раз запустим... То есть каждый раз при создании bean'а ему будет в поле repeat инжектится рандомное число.

## Init-методы и двухфазный конструктор

Ещё раз: что происходит? У нас есть два метода. Как вы видели, в одном я написал логику, в другом я ничего пока не сделал. Между вот этими двумя методами вызывается init-method.

Init-method - есть разные способы прописать для bean'а:
- Если вы работаете с XML, то вы можете init-method прописать через атрибут init-method в теге bean
- Если вы с аннотациями, вы можете поставить аннотацию @PostConstruct
- Если вы работаете на Spring 2, который ещё про аннотации не знает, то вы можете имплементировать интерфейс InitializingBean и прописать метод afterPropertiesSet()

Но так никто уже не делает лет 10.

Возникает вопрос: нафига нужны init-методы? Потому что в принципе есть конструктор. Что мы пишем в init-method? Мы пишем какую-то логику, которая инициализирует что-то. Для этого существовал конструктор. Чем стало плохо?

Для того чтобы объяснить про двухфазный конструктор, давайте сначала посмотрим, что произойдёт, если я попытаюсь в конструкторе пользоваться чем-то, что мне настраивает Spring.

```java
public TerminatorQuoter() {
    System.out.println("Phase 1: repeat = " + repeat);
}

@PostConstruct
public void init() {
    System.out.println("Phase 2: repeat = " + repeat);
}
```

Что будет напечатано в конструкторе? 0! Почему? Потому что Spring сначала создаст объект. Spring не делает никакой магии: сначала объект создаётся дефолтным способом. Spring инициализирует этот процесс - просканировал XML, создались BeanDefinition, Spring понял, что нужно создать singleton который называется TerminatorQuoter, при помощи reflection он запустил его конструктор, конструктор отработал, объект создался, и когда уже объект создан, Spring его может настраивать.

Соответственно, если мы в конструкторе пытаемся обратиться к каким-то вещам, которые должен настроить Spring, их ещё нету. Мы либо получаем нули в лучшем случае, а в худшем - наоборот. В лучшем случае мы получаем NullPointerException, а в худшем случае - нули. Понятно, почему лучше? Потому что лучше знать, что есть проблема, чем с каким-то нулём жить.

Поэтому что мы делаем? Вместо того чтобы пользоваться конструктором, мы можем написать init-method и в нём поставить вот эту логику, которую я привык раньше ставить в конструктор. То есть теперь конструктором мы не очень сильно будем пользоваться.

Но чтобы @PostConstruct работал, нужно добавить в контекст:

```xml
<bean class="org.springframework.context.annotation.CommonAnnotationBeanPostProcessor"/>
```

Или просто:

```xml
<context:annotation-config/>
```

Это прячет кучу BeanPostProcessor'ов, не только CommonAnnotationBeanPostProcessor, но ещё штук пять-шесть процессоров, которые относятся к тем аннотациям, которые вы знаете: @Transactional, @Scheduled, @Async и много других аннотаций.

Обычно вместо того чтобы его писать, человек делает вот так, не понимая на самом деле обычно что он делает:

```xml
<context:component-scan base-package="com.example"/>
```

Component-scan принимает какой-то пакет и, соответственно, кроме того что сканирует пакет, ещё и добавляет все эти процессоры в контекст.

## Диаграмма работы с BeanPostProcessor

Давайте подведём итоги, посмотрим, как работает всё сейчас, когда BeanPostProcessor'ы есть.

Опять начинается всё с того, что BeanDefinitionReader сканирует наш XML, положил сюда BeanDefinition. BeanFactory сначала из этих BeanDefinition вытащил определения BeanPostProcessor'ов, создал их и положил в сторонку, потому что он говорит: "Вы с моей точки зрения необычные beans. Вот эти Terminator'ы - это всё неинтересно, это человек что-то там какую-то бизнес-логику пишет, меня это не интересует. Я же BeanFactory, я же тут должен настраивать все вот эти Terminator'ы." Поэтому в первую очередь он создаст те beans, которые имплементируют BeanPostProcessor.

Потом все остальные beans, и поэтому всё это выглядит так:

1. До init-method - сначала после того как объект создался и настроился (BeanFactory сначала его полностью настроит согласно конфигурации), этот объект проходит через все BeanPostProcessor'ы (postProcessBeforeInitialization)
2. Вызывается init-method у данного bean'а
3. После init-method ещё один проход через BeanPostProcessor'ы (postProcessAfterInitialization)
4. В конце здесь у нас получаются полностью настроенные объекты уже при помощи процессоров

## Зачем два прохода через BeanPostProcessor?

Возникает вопрос: нафига вот эти два прохода через BeanPostProcessor'ы? Неужели было мало одного?

Сейчас я вам напишу достаточно сложный процессор, который будет делать профайлинг, который мы ещё сможем отключать через JMX.

### Профайлинг BeanPostProcessor

Давайте сделаем такую сложную вещь. Сначала я объясню идею того, что я хочу сделать.

Я хочу, чтобы все классы, над которыми стоит аннотация @Profiling, все их методы профилировались. Что такое "профилировать методы"? Я хочу, чтобы в лог выводилось время, сколько метод работает.

Теперь давайте подумаем, как мы это технически сможем сделать. Понятно, что опять же будет какой-то BeanPostProcessor, который будет к этой аннотации @Profiling относиться. Он будет получать bean от BeanFactory, он будет спрашивать: "А не стоит ли над классом этого bean'а аннотация @Profiling?" И если стоит, то ему придётся делать очень сложную работу - ему придётся в каждый метод данного bean'а дописывать логику, связанную с профайлингом.

Сама-то логика несложная - это надо замерить время до, запустить метод, замерить время после и вывести разницу на экран. Но как можно добавить логику в уже существующий объект?

Если бы вы работали на Groovy, то вы просто взяли бы существующий объект и добавили бы туда логику - с этим нет никакой проблемы. Groovy для этого очень динамичный язык, с ним очень легко что-то такое делать. В Java нужно будет на лету сгенерировать новый класс.

Теперь смотрите: если я на лету генерирую класс, из которого я создам объект, которым я заменю оригинальный объект, вы понимаете, что никто не должен заметить этой подмены. То есть представьте себе: мне BeanPostProcessor дали Terminator'а, я взял объект, говорю: "А его надо... ему нужно добавлять логику, связанную с профилированием." Причём вы понимаете же - не только профилирование, это могут быть транзакции, кэширование, бенчмарк - всё что угодно может быть, какой-то аспект.

Я говорю: "Мне надо ему добавлять логику." Хорошо, мы сейчас создадим новый класс, в котором мы будем делегировать на существующие уже методы и добавим туда эту логику. Но если и потом из этого класса я создам объект (то есть я сделаю такую декорацию-proxy) и верну его обратно в BeanFactory, никто же не должен заметить, что я подменил объект. Вы понимаете почему? Потому что человек попросил, чтобы ему создали Terminator'а, получил неизвестно что и не может даже работать, потому что не знает, какой контракт.

Поэтому новый класс, который сгенерится на лету, есть два варианта:
1. Либо он должен наследовать от оригинального класса и переопределять его методы, добавляя туда нужную логику
2. Либо он должен имплементировать те же самые интерфейсы

Есть совершенно два разных подхода:
- Первый подход называется **CGLib** - наследование от класса
- Второй подход называется **Dynamic Proxy** - имплементирование тех же самых интерфейсов

В принципе CGLib считается хуже (мы чуть позже поговорим о перформансе - увидите, что и по перформансу он больше бьёт), но дело даже не столько в этом, сколько в различных ограничениях. Вы не от любого класса можете наследовать - есть классы, которые final, есть методы, которые final, и соответственно мы здесь ограничены.

Поэтому Spring всегда предпочитает идти через интерфейсы. То есть Spring работает именно через proxy, и если Spring'овый proxy на какой-то объект, он сначала смотрит: "Есть ли у него интерфейсы?" Если да, то соответственно он идёт через Dynamic Proxy. Если нет, он идёт через CGLib.

Причём CGLib раньше нужно было добавлять как отдельную jar в ваш проект, а с четвёртого Spring'а (по-моему там с какой-то версии третьего, 3.2 что-то такое) они уже решили, что CGLib будет упакован вместе.

Ну давайте мы сейчас... К чему я всё это начал рассказывать? Теперь смотрите: если у нас появляются вот такие BeanPostProcessor'ы, которые могут взять и заменить оригинальный класс, скажите мне пожалуйста, что произойдёт вот здесь?

Могу ли я сейчас... у меня вот этот BeanPostProcessor, он исключительно рассчитывает на то, что вот этот `getClass()` вернёт оригинальный класс, в котором есть оригинальная мета-дата и в котором все поля аннотированы аннотациями. Потому что класс, который сгенерируется на лету, там никакой мета-даты не будет оригинальной, там никаких аннотаций не будет.

Таким образом, что получается? Аннотацию какую-то там - это не поможет. Есть AnnotationUtils, но опять там с этим возникают различные сложности.

Поэтому в принципе правильно (и так опять же по конвенциям Spring'а): BeanPostProcessor'ы, которые что-то в классе меняют, они должны это делать не на этапе `postProcessBeforeInitialization`, а они это делать должны на этапе `postProcessAfterInitialization`.

С другой стороны, мы тут достигаем ещё одну вещь - таким образом мы знаем, что @PostConstruct всегда работает на оригинальный метод, до того как всякие proxy накрутились на него.

### Реализация профайлинга

Поэтому смотрите, что мы сейчас сделаем. Мы сейчас всё-таки это напишем.

```java
@Retention(RetentionPolicy.RUNTIME)
public @interface Profiling {
}
```

```java
public class ProfilingHandlerBeanPostProcessor implements BeanPostProcessor {

    private Map<String, Class> originalClasses = new HashMap<>();

    @Override
    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
        Class<?> beanClass = bean.getClass();
        if (beanClass.isAnnotationPresent(Profiling.class)) {
            originalClasses.put(beanName, beanClass);
        }
        return bean;
    }

    @Override
    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
        Class beanClass = originalClasses.get(beanName);
        if (beanClass != null) {
            return Proxy.newProxyInstance(beanClass.getClassLoader(),
                                        beanClass.getInterfaces(),
                                        new ProfilingInvocationHandler(bean));
        }
        return bean;
    }
}
```

Создадим также контроллер для управления профайлингом через JMX:

```java
public class ProfilingController implements ProfilingControllerMBean {
    private boolean enabled = false;

    public boolean isEnabled() { return enabled; }
    public void setEnabled(boolean enabled) { this.enabled = enabled; }
}

public interface ProfilingControllerMBean {
    void setEnabled(boolean enabled);
}
```

И InvocationHandler:

```java
public class ProfilingInvocationHandler implements InvocationHandler {
    private final Object target;
    private final ProfilingController controller;

    public ProfilingInvocationHandler(Object target) {
        this.target = target;
        this.controller = new ProfilingController();
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        if (controller.isEnabled()) {
            long before = System.nanoTime();
            Object result = method.invoke(target, args);
            long after = System.nanoTime();
            System.out.println("Профилирование: " + (after - before));
            return result;
        } else {
            return method.invoke(target, args);
        }
    }
}
```

## Трёхфазный конструктор и @PostProxy

Теперь возникает проблема: если я хочу использовать метод в @PostConstruct, который должен работать с транзакциями, то транзакции на этапе работы @PostConstruct ещё не существуют, они не настроены. Это понятно, почему транзакции не настроены - потому что кто настраивает транзакции? BeanPostProcessor, который за аннотацию @Transactional отвечает, логику, связанную с транзакцией, запекает в этот класс после того, как @PostConstruct отработал.

Потому что вы же помните: есть два этапа - сначала `postProcessBeforeInitialization`, потом @PostConstruct, а потом `postProcessAfterInitialization`. То есть соответственно @PostConstruct работает до того, как настроились все proxy, включая те proxy, которые отвечают за транзакции.

Что делать? Поэтому я хочу иметь третью фазу конструктора. Я сейчас придумаю свою аннотацию, которая будет называться @PostProxy.

```java
@Retention(RetentionPolicy.RUNTIME)
public @interface PostProxy {
}
```

```java
@Component
public class PostProxyInvokerContextListener implements ApplicationListener<ContextRefreshedEvent> {

    @Autowired
    private ConfigurableListableBeanFactory factory;

    @Override
    public void onApplicationEvent(ContextRefreshedEvent event) {
        ApplicationContext context = event.getApplicationContext();
        String[] names = context.getBeanDefinitionNames();

        for (String name : names) {
            BeanDefinition beanDefinition = factory.getBeanDefinition(name);
            String originalClassName = beanDefinition.getBeanClassName();

            try {
                Class originalClass = Class.forName(originalClassName);
                Method[] methods = originalClass.getMethods();

                for (Method method : methods) {
                    if (method.isAnnotationPresent(PostProxy.class)) {
                        Object bean = context.getBean(name);
                        Class currentClass = bean.getClass();
                        Method currentMethod = currentClass.getMethod(method.getName(), method.getParameterTypes());
                        currentMethod.invoke(bean);
                    }
                }
            } catch (Exception e) {
                // обработка исключений
            }
        }
    }
}
```

Теперь у нас трёхфазный конструктор:
1. **Фаза 1**: Обычный Java конструктор
2. **Фаза 2**: @PostConstruct (после DI, но до proxy)
3. **Фаза 3**: @PostProxy (после всех proxy, включая транзакционные)

Это решает проблему с транзакциями в init-методах!

## Заключение

Мы рассмотрели:
- Как работает Spring изнутри
- BeanDefinition и BeanFactory
- BeanPostProcessor и их применение
- Двухфазный и трёхфазный конструкторы
- Dynamic Proxy и CGLib
- Профайлинг через аспекты
- JMX интеграцию

Это основы того, как Spring создаёт и настраивает объекты. В следующей части мы поговорим о влиянии на производительность.